.. _ifp:

.. include:: /_static/includes/lecture_howto_py.raw

.. highlight:: python3

********************************************************************
:index:`Optimal Savings III: Occasionally Binding Constraints`
********************************************************************

.. contents:: :depth: 2

Overview
============

Next we study an optimal savings problem for an infinitely lived consumer---the "common ancestor" described in :cite:`Ljungqvist2012`, section 1.3

This is an essential sub-problem for many representative macroeconomic models

* :cite:`Aiyagari1994`

* :cite:`Huggett1993`

* etc.

It is related to the decision problem in the :doc:`stochastic optimal growth
model <optgrowth>` and yet differs in important ways

For example, the choice problem for the agent includes an additive income term that leads to an occasionally binding constraint

Our presentation of the model will be relatively brief

.. only:: html

    * For further details on economic intuition, implication and models, see :cite:`Ljungqvist2012`
    * Proofs of all mathematical results stated below can be found in :download:`this paper </_static/pdfs/pi2.pdf>`

.. only:: latex

    * For further details on economic intuition, implication and models, see :cite:`Ljungqvist2012`
    * Proofs of all mathematical results stated below can be found in `this paper <https://lectures.quantecon.org/_downloads/pi2.pdf>`__

To solve the model we will use Euler equation based time iteration, similar to :doc:`this lecture <coleman_policy_iter>`

This method turns out to be

* Globally convergent under mild assumptions, even when utility is unbounded (both above and below)

* More efficient numerically than value function iteration



References
----------------

Other useful references include :cite:`Deaton1991`, :cite:`DenHaan2010`, :cite:`Kuhn2013`, :cite:`Rabault2002`,  :cite:`Reiter2009`  and :cite:`SchechtmanEscudero1977`


The Optimal Savings Problem
===============================

.. index::
    single: Optimal Savings; Problem

Let's write down the model and then discuss how to solve it

Set Up
---------

Consider a household that chooses a state-contingent consumption plan :math:`\{c_t\}_{t \geq 0}` to maximize

.. math::

    \mathbb{E} \, \sum_{t=0}^{\infty} \beta^t u(c_t)


subject to

.. math::
    :label: eqst

    c_t + a_{t+1} \leq  Ra_t  + z_t,
    \qquad c_t \geq 0,
    \qquad a_t \geq -b
    \qquad t = 0, 1, \ldots


Here

* :math:`\beta \in (0,1)` is the discount factor

* :math:`a_t` is asset holdings at time :math:`t`, with ad-hoc borrowing constraint :math:`a_t \geq -b`

* :math:`c_t` is consumption

* :math:`z_t` is non-capital income (wages, unemployment compensation, etc.)

* :math:`R := 1 + r`, where :math:`r > 0` is the interest rate on savings


Non-capital income :math:`\{z_t\}` is assumed to be a Markov process taking values in :math:`Z\subset (0,\infty)` with stochastic kernel :math:`\Pi` 

This means that :math:`\Pi(z, B)` is the probability that :math:`z_{t+1} \in
B` given :math:`z_t = z`

The expectation of :math:`f(z_{t+1})` given :math:`z_t = z` is written as

.. math::

    \int f( \acute z) \, \Pi(z, d \acute z)

We further assume that

#. :math:`r > 0` and :math:`\beta R < 1`

#. :math:`u` is smooth, strictly increasing and strictly concave with :math:`\lim_{c \to 0} u'(c) = \infty` and :math:`\lim_{c \to \infty} u'(c) = 0`



The asset space is :math:`[-b, \infty)` and the state is the pair :math:`(a,z) \in S := [-b,\infty) \times Z`

A *feasible consumption path* from :math:`(a,z) \in S` is a consumption
sequence :math:`\{c_t\}` such that :math:`\{c_t\}` and its induced asset path :math:`\{a_t\}` satisfy

#. :math:`(a_0, z_0) = (a, z)`

#. the feasibility constraints in :eq:`eqst`, and

#. measurability of :math:`c_t` w.r.t. the filtration generated by :math:`\{z_1, \ldots, z_t\}`

The meaning of the third point is just that consumption at time :math:`t` can only be
a function of outcomes that have already been observed


Value Function and Euler Equation
------------------------------------

The *value function* :math:`V \colon S \to \mathbb{R}` is defined by

.. math::
    :label: eqvf

    V(a, z) := \sup \, \mathbb{E}
    \left\{
    \sum_{t=0}^{\infty} \beta^t u(c_t)
    \right\}


where the supremum is over all feasible consumption paths from :math:`(a,z)`.


An *optimal consumption path* from :math:`(a,z)` is a feasible consumption path from :math:`(a,z)` that attains the supremum in :eq:`eqvf`

To pin down such paths we can use a version of the Euler equation, which in the present setting is

.. math::
    :label: ee00

    u' (c_t)
    \geq \beta R \,  \mathbb{E}_t [ u'(c_{t+1}) ] 

and

.. math::
    :label: ee01

    u' (c_t) = \beta R \,  \mathbb{E}_t [ u'(c_{t+1}) ] 
    \quad \text{whenever }
    c_t < Ra_t + z_t + b

In essence, this says that the natural "arbitrage" relation :math:`u' (c_t) = \beta R \,  \mathbb{E}_t [ u'(c_{t+1}) ]` holds when the choice of current consumption is interior

Interiority means that :math:`c_t` is strictly less than its upper bound :math:`Ra_t + z_t + b`

(The lower boundary case :math:`c_t = 0` never arises at the optimum because
:math:`u'(0) = \infty`)

When :math:`c_t` does hit the upper bound :math:`Ra_t + z_t + b`, the 
strict inequality :math:`u' (c_t) > \beta R \,  \mathbb{E}_t [ u'(c_{t+1}) ]`
can occur because :math:`c_t` cannot increase sufficiently to attain equality


With some thought and effort, one can show that :eq:`ee00` and :eq:`ee01` are
equivalent to

.. math::
    :label: eqeul0

    u' (c_t)
    = \max \left\{
    \beta R \,  \mathbb{E}_t [ u'(c_{t+1}) ] \,,\;  u'(Ra_t + z_t + b)
    \right\}


Optimality Results
------------------


.. only:: html

    Given our assumptions, it is :download:`known </_static/pdfs/pi2.pdf>` that

.. only:: latex

    Given our assumptions, it is `known <https://lectures.quantecon.org/_downloads/pi2.pdf>`__ that


#. For each :math:`(a,z) \in S`, a unique optimal consumption path from :math:`(a,z)` exists

#. This path is the unique feasible path from :math:`(a,z)` satisfying the
   Euler equality :eq:`eqeul0` and the transversality condition

.. math::
    :label: eqtv

    \lim_{t \to \infty} \beta^t \, \mathbb{E} \, [ u'(c_t) a_{t+1} ] = 0.


Moreover, there exists an *optimal consumption function* :math:`c^* \colon S \to [0, \infty)` such that the path from :math:`(a,z)` generated by

.. math::

    (a_0, z_0) = (a, z),
    \quad
    z_{t+1} \sim \Pi(z_t, dy),
    \quad
    c_t = c^*(a_t, z_t)
    \quad \text{and} \quad
    a_{t+1} = R a_t + z_t - c_t


satisfies both :eq:`eqeul0` and :eq:`eqtv`, and hence is the unique optimal
path from :math:`(a,z)`

In summary, to solve the optimization problem, we need to compute :math:`c^*`


.. _ifp_computation:

Computation
===============

.. index::
    single: Optimal Savings; Computation

There are two standard ways to solve for :math:`c^*`

#. Time iteration (TI) using the Euler equality 

#. Value function iteration (VFI)

Let's look at these in turn

Time Iteration
-----------------------------

We can rewrite :eq:`eqeul0` to make it a statement about functions rather than
random variables

In particular, consider the functional equation

.. math::
    :label: eqeul1

    u' \circ c \, (a, z)
    = \max \left\{
    \gamma \int u' \circ c \, \{R a + z - c(a, z), \, \acute z\}
    \, \Pi(z,d \acute z)
    \, , \;
         u'(Ra + z + b)
         \right\}


where :math:`\gamma := \beta R` and :math:`u' \circ c(s) := u'(c(s))`

Equation :eq:`eqeul1` is a functional equation in :math:`c`

In order to identify a solution, let :math:`\mathscr{C}` be the set of candidate consumption functions :math:`c \colon S \to \mathbb R` such that

* each :math:`c \in \mathscr{C}` is continuous and (weakly) increasing
* :math:`\min Z \leq c(a,z) \leq Ra + z + b` for all :math:`(a,z) \in S`

In addition, let :math:`K \colon \mathscr{C} \to \mathscr{C}` be defined as follows:

For given :math:`c\in \mathscr{C}`, the value :math:`Kc(a,z)` is the unique :math:`t \in J(a,z)` that solves

.. math::
    :label: eqsifc

    u'(t)
    = \max \left\{
    \gamma \int u' \circ c \, \{R a + z - t, \, \acute z\}
    \, \Pi(z,d \acute z)
    \, , \;
         u'(Ra + z + b)
         \right\}


where

.. math::
    :label: eqbos

    J(a,z) := \{t \in \mathbb{R} \,:\, \min Z \leq t \leq Ra+ z + b\}


We refer to :math:`K` as Coleman's policy function operator :cite:`Coleman1990`

.. only:: html

    It is :download:`known </_static/pdfs/pi2.pdf>` that

.. only:: latex

    It is `known <https://lectures.quantecon.org/_downloads/pi2.pdf>`__ that

* :math:`K` is a contraction mapping on :math:`\mathscr{C}` under the metric

.. math::

    \rho(c, d) := \| \, u' \circ c - u' \circ d \, \|
        := \sup_{s \in S} | \, u'(c(s))  - u'(d(s)) \, |
     \qquad \quad (c, d \in \mathscr{C})


* The metric :math:`\rho` is complete on :math:`\mathscr{C}`
* Convergence in :math:`\rho` implies uniform convergence on compacts

In consequence, :math:`K` has a unique fixed point :math:`c^* \in \mathscr{C}`
and :math:`K^n c \to c^*` as :math:`n \to \infty` for any :math:`c \in \mathscr{C}`

By the definition of :math:`K`, the fixed points of :math:`K` in :math:`\mathscr{C}` coincide with
the solutions to :eq:`eqeul1` in :math:`\mathscr{C}`

.. only:: html

    In particular, it :download:`can be shown </_static/pdfs/pi2.pdf>` that the path :math:`\{c_t\}`
    generated from :math:`(a_0,z_0) \in S` using policy function :math:`c^*` is
    the unique optimal path from :math:`(a_0,z_0) \in S`

.. only:: latex

    In particular, it `can be shown <https://lectures.quantecon.org/_downloads/pi2.pdf>`__ that the path :math:`\{c_t\}`
    generated from :math:`(a_0,z_0) \in S` using policy function :math:`c^*` is
    the unique optimal path from :math:`(a_0,z_0) \in S`

**TL;DR** The unique optimal policy can be computed by picking any
:math:`c \in \mathscr{C}` and iterating with the operator :math:`K` defined in :eq:`eqsifc`

Value Function Iteration
-----------------------------


The Bellman operator for this problem is given by

.. math::
    :label: eqbop

    Tv(a, z)
    = \max_{0 \leq c \leq Ra + z + b}
    \left\{
        u(c) + \beta \int v(Ra + z - c, \acute z) \Pi(z, d \acute z)
    \right\}


We have to be careful with VFI (i.e., iterating with
:math:`T`) in this setting because :math:`u` is not assumed to be bounded

* In fact typically unbounded both above and below --- e.g. :math:`u(c) = \log c`
* In which case, the standard DP theory does not apply
* :math:`T^n v` is not guaranteed to converge to the value function for arbitrary continous bounded :math:`v`

Nonetheless, we can always try the popular strategy "iterate and hope"

We can then check the outcome by comparing with that produced by TI

The latter is known to converge, as described above


Implementation
-----------------

.. index::
    single: Optimal Savings; Programming Implementation

Here's the code for a class called ``ConsumerProblem`` that stores primitives, as well as

* a ``bellman_operator`` function, which implements the Bellman operator :math:`T` specified above

* a ``coleman_operator`` function, which implements the Coleman operator :math:`K` specified above

* an ``initialize``, which generates suitable initial conditions for iteration


.. code-block:: python3

    import numpy as np
    from scipy.optimize import fminbound, brentq

    class ConsumerProblem:
        """
        A class that stores primitives for the income fluctuation problem.  The
        income process is assumed to be a finite state Markov chain.

        Parameters
        ----------
        r : scalar(float), optional(default=0.01)
            A strictly positive scalar giving the interest rate
        β : scalar(float), optional(default=0.96)
            The discount factor, must satisfy (1 + r) * β < 1
        Π : array_like(float), optional(default=((0.60, 0.40),(0.05, 0.95))
            A 2D NumPy array giving the Markov matrix for {z_t}
        z_vals : array_like(float), optional(default=(0.5, 0.95))
            The state space of {z_t}
        b : scalar(float), optional(default=0)
            The borrowing constraint
        grid_max : scalar(float), optional(default=16)
            Max of the grid used to solve the problem
        grid_size : scalar(int), optional(default=50)
            Number of grid points to solve problem, a grid on [-b, grid_max]
        u : callable, optional(default=np.log)
            The utility function
        du : callable, optional(default=lambda x: 1/x)
            The derivative of u

        Attributes
        ----------
        r, β, Π, z_vals, b, u, du : see Parameters
        asset_grid : np.ndarray
            One dimensional grid for assets

        """

        def __init__(self, 
                     r=0.01, 
                     β=0.96, 
                     Π=((0.6, 0.4), (0.05, 0.95)),
                     z_vals=(0.5, 1.0), 
                     b=0, 
                     grid_max=16, 
                     grid_size=50,
                     u=np.log, 
                     du=lambda x: 1/x):

            self.u, self.du = u, du
            self.r, self.R = r, 1 + r
            self.β, self.b = β, b
            self.Π, self.z_vals = np.array(Π), tuple(z_vals)
            self.asset_grid = np.linspace(-b, grid_max, grid_size)


    def bellman_operator(V, cp, return_policy=False):
        """
        The approximate Bellman operator, which computes and returns the
        updated value function TV (or the V-greedy policy c if
        return_policy is True).

        Parameters
        ----------
        V : array_like(float)
            A NumPy array of dim len(cp.asset_grid) times len(cp.z_vals)
        cp : ConsumerProblem
            An instance of ConsumerProblem that stores primitives
        return_policy : bool, optional(default=False)
            Indicates whether to return the greed policy given V or the
            updated value function TV.  Default is TV.

        Returns
        -------
        array_like(float)
            Returns either the greed policy given V or the updated value
            function TV.

        """
        # === Simplify names, set up arrays === #
        R, Π, β, u, b = cp.R, cp.Π, cp.β, cp.u, cp.b
        asset_grid, z_vals = cp.asset_grid, cp.z_vals
        new_V = np.empty(V.shape)
        new_c = np.empty(V.shape)
        z_idx = list(range(len(z_vals)))

        # === Linear interpolation of V along the asset grid === #
        vf = lambda a, i_z: np.interp(a, asset_grid, V[:, i_z])

        # === Solve r.h.s. of Bellman equation === #
        for i_a, a in enumerate(asset_grid):
            for i_z, z in enumerate(z_vals):
                def obj(c):  # objective function to be *minimized*
                    y = sum(vf(R * a + z - c, j) * Π[i_z, j] for j in z_idx)
                    return - u(c) - β * y
                c_star = fminbound(obj, 1e-8, R * a + z + b)
                new_c[i_a, i_z], new_V[i_a, i_z] = c_star, -obj(c_star)

        if return_policy:
            return new_c
        else:
            return new_V

    def coleman_operator(c, cp):
        """
        The approximate Coleman operator.

        Iteration with this operator corresponds to time iteration on the Euler
        equation.  Computes and returns the updated consumption policy
        c.  The array c is replaced with a function cf that implements
        univariate linear interpolation over the asset grid for each
        possible value of z.

        Parameters
        ----------
        c : array_like(float)
            A NumPy array of dim len(cp.asset_grid) times len(cp.z_vals)
        cp : ConsumerProblem
            An instance of ConsumerProblem that stores primitives

        Returns
        -------
        array_like(float)
            The updated policy, where updating is by the Coleman
            operator.

        """
        # === simplify names, set up arrays === #
        R, Π, β, du, b = cp.R, cp.Π, cp.β, cp.du, cp.b
        asset_grid, z_vals = cp.asset_grid, cp.z_vals
        z_size = len(z_vals)
        γ = R * β
        vals = np.empty(z_size)

        # === linear interpolation to get consumption function === #
        def cf(a):
            """
            The call cf(a) returns an array containing the values c(a,
            z) for each z in z_vals.  For each such z, the value c(a, z)
            is constructed by univariate linear approximation over asset
            space, based on the values in the array c
            """
            for i in range(z_size):
                vals[i] = np.interp(a, asset_grid, c[:, i])
            return vals

        # === solve for root to get Kc === #
        Kc = np.empty(c.shape)
        for i_a, a in enumerate(asset_grid):
            for i_z, z in enumerate(z_vals):
                def h(t):
                    expectation = np.dot(du(cf(R * a + z - t)), Π[i_z, :])
                    return du(t) - max(γ * expectation, du(R * a + z + b))
                Kc[i_a, i_z] = brentq(h, 1e-8, R * a + z + b)

        return Kc

    def initialize(cp):
        """
        Creates a suitable initial conditions V and c for value function and time
        iteration respectively.

        Parameters
        ----------
        cp : ConsumerProblem
            An instance of ConsumerProblem that stores primitives

        Returns
        -------
        V : array_like(float)
            Initial condition for value function iteration
        c : array_like(float)
            Initial condition for Coleman operator iteration

        """
        # === Simplify names, set up arrays === #
        R, β, u, b = cp.R, cp.β, cp.u, cp.b
        asset_grid, z_vals = cp.asset_grid, cp.z_vals
        shape = len(asset_grid), len(z_vals)
        V, c = np.empty(shape), np.empty(shape)

        # === Populate V and c === #
        for i_a, a in enumerate(asset_grid):
            for i_z, z in enumerate(z_vals):
                c_max = R * a + z + b
                c[i_a, i_z] = c_max
                V[i_a, i_z] = u(c_max) / (1 - β)

        return V, c


Both ``bellman_operator`` and ``coleman_operator`` use linear interpolation along the asset grid to approximate the value and consumption functions

The following exercises walk you through several applications where policy functions are computed

In exercise 1 you will see that while VFI and TI produce similar results, the latter is much faster

Intuition behind this fact was provided in :doc:`a previous lecture on time iteration <coleman_policy_iter>`

Exercises
=============


.. _ifp_ex1:

Exercise 1
------------

The first exercise is to replicate the following figure, which compares TI and VFI as solution methods

.. figure:: /_static/figures/vfi_vs_pfi.png
   :scale: 100%

The figure shows consumption policies computed by iteration of :math:`K` and :math:`T` respectively

* In the case of iteration with :math:`T`, the final value function is used to compute the observed policy

Consumption is shown as a function of assets with income :math:`z` held fixed
at its smallest value

The following details are needed to replicate the figure

* The parameters are the default parameters in the definition of ``consumerProblem``
* The initial conditions are the default ones from ``initialize()``
* Both operators are iterated 80 times

When you run your code you will observe that iteration with :math:`K` is
faster than iteration with :math:`T`

In the IPython shell, a comparison of the operators can be made as follows



.. code-block:: python3

    cp = ConsumerProblem()
    v, c = initialize(cp)


.. code-block:: ipython

    %timeit bellman_operator(v, cp)
    
    
.. code-block:: ipython

    %timeit coleman_operator(c, cp)
  






The output shows that Coleman operator is about 6 times faster

From now on we will only use the Coleman operator





.. _ifp_ex2:

Exercise 2
------------

Next let's consider how the interest rate affects consumption

Reproduce the following figure, which shows (approximately) optimal consumption policies for different interest rates

.. figure:: /_static/figures/ifp_policies.png
   :scale: 100%

* Other than `r`, all parameters are at their default values
* `r` steps through `np.linspace(0, 0.04, 4)`
* Consumption is plotted against assets for income shock fixed at the smallest value

The figure shows that higher interest rates boost savings and hence suppress consumption






.. _ifp_ex3:

Exercise 3
------------

Now let's consider the long run asset levels held by households

We'll take `r = 0.03` and otherwise use default parameters

The following figure is a 45 degree diagram showing the law of motion for assets when consumption is optimal



.. code-block:: python3

    import matplotlib.pyplot as plt
    import quantecon as qe
    

    # === solve for optimal consumption === #
    m = ConsumerProblem(r=0.03, grid_max=4)
    v_init, c_init = initialize(m)

    K = lambda c: coleman_operator(c, m)
    c = qe.compute_fixed_point(K, c_init, verbose=False)
    a = m.asset_grid
    R, z_vals = m.R, m.z_vals

    # === generate savings plot === #
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.plot(a, R * a + z_vals[0] - c[:, 0], label='Low income')
    ax.plot(a, R * a + z_vals[1] - c[:, 1], label='High income')
    ax.plot(a, a, 'k--')
    ax.set(xlabel='Current assets', ylabel='Next period assets', 
           xlim=(0, 4), ylim=(0, 4))
    ax.legend()
    plt.show()





The blue line and orange line represent the function

.. math::

    a' = h(a, z) := R a + z - c^*(a, z)


when income :math:`z` takes its high and low values respectively

The dashed line is the 45 degree line

We can see from the figure that the dynamics will be stable --- assets do not
diverge

In fact there is a unique stationary distribution of assets that we can calculate by simulation

* Can be proved via theorem 2 of :cite:`HopenhaynPrescott1992`

* Represents the long run dispersion of assets across households when households have idiosyncratic shocks


Ergodicity is valid here, so stationary probabilities can be calculated by averaging over a single long time series

* Hence to approximate the stationary distribution we can simulate a long time series for assets and histogram, as in the following figure

.. figure:: /_static/figures/ifp_histogram.png
   :scale: 100%

Your task is to replicate the figure

* Parameters are as discussed above

* The histogram in the figure used a single time series :math:`\{a_t\}` of length 500,000

* Given the length of this time series, the initial condition :math:`(a_0, z_0)` will not matter

* You might find it helpful to use the ``MarkovChain`` class from ``quantecon``



.. _ifp_ex4:

Exercise 4
------------

Following on from exercises 2 and 3, let's look at how savings and aggregate asset holdings vary with the interest rate

* Note: :cite:`Ljungqvist2012` section 18.6 can be consulted for more background on the topic treated in this exercise

For a given parameterization of the model, the mean of the stationary distribution can be interpreted as aggregate capital in an economy with a unit mass of *ex-ante* identical households facing idiosyncratic shocks

Let's look at how this measure of aggregate capital varies with the interest
rate and borrowing constraint

The next figure plots aggregate capital against the interest rate for `b in (1, 3)`


.. figure:: /_static/figures/ifp_agg_savings.png
   :scale: 100%

As is traditional, the price (interest rate) is on the vertical axis

The horizontal axis is aggregate capital computed as the mean of the stationary distribution

Exercise 4 is to replicate the figure, making use of code from previous exercises

Try to explain why the measure of aggregate capital is equal to :math:`-b`
when :math:`r=0` for both cases shown here

Solutions
==========




Exercise 1
----------

.. code-block:: python3

    cp = ConsumerProblem()
    K = 80
    
    # Bellman iteration 
    V, c = initialize(cp)
    print("Starting value function iteration")
    for i in range(K):
        # print f"Current iterate = {i}")
        V = bellman_operator(V, cp)  
    c1 = bellman_operator(V, cp, return_policy=True)  
    
    # Policy iteration 
    print("Starting policy function iteration")
    V, c2 = initialize(cp)
    for i in range(K):
        # print f"Current iterate = {i}"
        c2 = coleman_operator(c2, cp)
    
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.plot(cp.asset_grid, c1[:, 0], label='value function iteration')
    ax.plot(cp.asset_grid, c2[:, 0], label='policy function iteration')
    ax.set_xlabel('asset level')
    ax.set_ylabel('consumption (low income)')
    ax.legend(loc='upper left')
    plt.show()


Exercise 2
----------

.. code-block:: python3

    
    r_vals = np.linspace(0, 0.04, 4)  
    
    fig, ax = plt.subplots(figsize=(10, 8))
    for r_val in r_vals:
        cp = ConsumerProblem(r=r_val)
        v_init, c_init = initialize(cp)
        K = lambda c: coleman_operator(c, cp)
        c = qe.compute_fixed_point(K, c_init, verbose=False)
        ax.plot(cp.asset_grid, c[:, 0], label=f'$r = {r_val:.3f}$')
    
    ax.set_xlabel('asset level')
    ax.set_ylabel('consumption (low income)')
    ax.legend(loc='upper left')
    plt.show()


Exercise 3
----------

.. code-block:: python3

    
    from quantecon import MarkovChain
    
    def compute_asset_series(cp, T=500000, verbose=False):
        """
        Simulates a time series of length T for assets, given optimal savings
        behavior. Parameter cp is an instance of ConsumerProblem
        """
    
        Π, z_vals, R = cp.Π, cp.z_vals, cp.R  # Simplify names
        mc = MarkovChain(Π)
        v_init, c_init = initialize(cp)
        K = lambda c: coleman_operator(c, cp)
        c = qe.compute_fixed_point(K, c_init, verbose=verbose)
        cf = lambda a, i_z: np.interp(a, cp.asset_grid, c[:, i_z])
        a = np.zeros(T+1)
        z_seq = mc.simulate(T)
        for t in range(T):
            i_z = z_seq[t]
            a[t+1] = R * a[t] + z_vals[i_z] - cf(a[t], i_z)
        return a
    
    cp = ConsumerProblem(r=0.03, grid_max=4)
    a = compute_asset_series(cp)
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.hist(a, bins=20, alpha=0.5, normed=True)
    ax.set_xlabel('assets')
    ax.set_xlim(-0.05, 0.75)
    plt.show()


Exercise 4
----------

The following code takes a little while to run

.. code-block:: python3

    
    M = 25
    r_vals = np.linspace(0, 0.04, M)  
    fig, ax = plt.subplots(figsize=(10,8))
    
    for b in (1, 3):
        asset_mean = []
        for r_val in r_vals:
            cp = ConsumerProblem(r=r_val, b=b)
            mean = np.mean(compute_asset_series(cp, T=250000))
            asset_mean.append(mean)
        ax.plot(asset_mean, r_vals, label=f'$b = {b:d}$')
        print(f"Finished iteration b={b:d}")
    
    ax.set_yticks(np.arange(.0, 0.045, .01))
    ax.set_xticks(np.arange(-3, 2, 1))
    ax.set_xlabel('capital')
    ax.set_ylabel('interest rate')
    ax.grid(True)
    ax.legend(loc='upper left')
    plt.show()




